"""IPC server for daemon communication using HTTP (cross-platform)."""

import asyncio
import json
import logging
from collections.abc import Callable
from pathlib import Path
from typing import Any

from aiohttp import web

logger = logging.getLogger(__name__)


class IPCServer:
    """IPC server using Unix sockets or Windows named pipes."""

    def __init__(self, socket_path: Path, handler: Callable[[dict[str, Any]], dict[str, Any]]):
        """Initialize IPC server.

        Args:
            socket_path: Path to Unix socket or named pipe
            handler: Request handler function
        """
        self.socket_path = socket_path
        self.handler = handler
        self.server: asyncio.Server | None = None
        self._pipe_task: asyncio.Task[None] | None = None
        self._is_windows = sys.platform == "win32"

    async def start(self) -> None:
        """Start the IPC server."""
        # Remove stale socket if it exists
        if self.socket_path.exists() and not self._is_windows:
            self.socket_path.unlink()

        if self._is_windows:
            # Windows named pipe - use global imports
            if win32pipe is None or win32file is None or pywintypes is None:
                raise RuntimeError("pywin32 not available - cannot use Windows named pipes")

            pipe_name = f"\\\\.\\pipe\\{self.socket_path.name}"
            logger.info(f"Starting Windows named pipe server: {pipe_name}")

            async def handle_pipe() -> None:
                loop = asyncio.get_event_loop()
                while True:
                    try:
                        # Create pipe synchronously
                        pipe = win32pipe.CreateNamedPipe(
                            pipe_name,
                            win32pipe.PIPE_ACCESS_DUPLEX,
                            win32pipe.PIPE_TYPE_MESSAGE | win32pipe.PIPE_READMODE_MESSAGE | win32pipe.PIPE_WAIT,
                            win32pipe.PIPE_UNLIMITED_INSTANCES,
                            65536,
                            65536,
                            0,
                            None,
                        )
                        
                        # Run blocking ConnectNamedPipe in executor
                        await loop.run_in_executor(None, win32pipe.ConnectNamedPipe, pipe, None)
                        
                        try:
                            # Run blocking ReadFile in executor
                            data = await loop.run_in_executor(None, lambda: win32file.ReadFile(pipe, 65536)[1])
                            request = json.loads(data.decode("utf-8"))
                            response = self.handler(request)
                            # Run blocking WriteFile in executor
                            await loop.run_in_executor(
                                None, win32file.WriteFile, pipe, json.dumps(response).encode("utf-8")
                            )
                        finally:
                            win32file.CloseHandle(pipe)
                    except Exception as e:
                        if pywintypes and isinstance(e, pywintypes.error):
                            logger.error(f"Pipe error: {e}")
                        else:
                            logger.error(f"Unexpected error: {e}")
                        await asyncio.sleep(0.1)

            self._pipe_task = asyncio.create_task(handle_pipe())
        else:
            # Unix socket
            self.server = await asyncio.start_unix_server(self._handle_connection, path=str(self.socket_path))  # type: ignore
            logger.info(f"IPC server listening on {self.socket_path}")

    async def _handle_connection(self, reader: asyncio.StreamReader, writer: asyncio.StreamWriter) -> None:
        """Handle a client connection."""
        try:
            data = await reader.read(65536)
            if not data:
                return

            request = json.loads(data.decode("utf-8"))
            logger.debug(f"Received request: {request}")

            response = self.handler(request)
            writer.write(json.dumps(response).encode("utf-8"))
            await writer.drain()

        except json.JSONDecodeError as e:
            logger.error(f"Invalid JSON: {e}")
            error_response = {"error": "Invalid JSON"}
            writer.write(json.dumps(error_response).encode("utf-8"))
            await writer.drain()
        except Exception as e:
            logger.error(f"Error handling request: {e}")
            error_response = {"error": str(e)}
            writer.write(json.dumps(error_response).encode("utf-8"))
            await writer.drain()
        finally:
            writer.close()
            await writer.wait_closed()

    async def stop(self) -> None:
        """Stop the IPC server."""
        if self._is_windows and self._pipe_task:
            # Cancel Windows pipe task
            self._pipe_task.cancel()
            try:
                await self._pipe_task
            except asyncio.CancelledError:
                pass
        elif self.server:
            # Stop Unix socket server
            self.server.close()
            await self.server.wait_closed()

        if self.socket_path.exists() and not self._is_windows:
            self.socket_path.unlink()


class IPCClient:
    """IPC client for communicating with daemon."""

    def __init__(self, socket_path: Path):
        """Initialize IPC client.

        Args:
            socket_path: Path to Unix socket or named pipe
        """
        self.socket_path = socket_path
        self._is_windows = sys.platform == "win32"

    async def send_request(self, request: dict[str, Any], timeout: float = 5.0) -> dict[str, Any]:
        """Send request to daemon and get response.

        Args:
            request: Request data
            timeout: Request timeout in seconds

        Returns:
            Response data
        """
        if self._is_windows:
            return await self._send_request_windows(request, timeout)
        return await self._send_request_unix(request, timeout)

    async def _send_request_unix(self, request: dict[str, Any], timeout: float) -> dict[str, Any]:
        """Send request via Unix socket."""
        try:
            reader, writer = await asyncio.wait_for(
                asyncio.open_unix_connection(str(self.socket_path)),  # type: ignore[attr-defined]
                timeout=timeout,
            )

            writer.write(json.dumps(request).encode("utf-8"))
            await writer.drain()

            data = await asyncio.wait_for(reader.read(65536), timeout=timeout)
            response: dict[str, Any] = json.loads(data.decode("utf-8"))

            writer.close()
            await writer.wait_closed()

            return response
        except TimeoutError:
            raise TimeoutError(f"Request timed out after {timeout}s")
        except FileNotFoundError:
            raise ConnectionError(f"Daemon not running (socket not found: {self.socket_path})")
        except Exception as e:
            raise ConnectionError(f"Failed to communicate with daemon: {e}")

    async def _send_request_windows(self, request: dict[str, Any], timeout: float) -> dict[str, Any]:  # type: ignore[return]
        """Send request via Windows named pipe."""
        # Use global imports
        if win32file is None or pywintypes is None:
            raise ConnectionError("pywin32 not available - cannot use Windows named pipes")

        pipe_name = f"\\\\.\\pipe\\{self.socket_path.name}"
        try:
            handle = win32file.CreateFile(
                pipe_name,
                win32file.GENERIC_READ | win32file.GENERIC_WRITE,
                0,
                None,
                win32file.OPEN_EXISTING,
                0,
                None,
            )
            try:
                win32file.WriteFile(handle, json.dumps(request).encode("utf-8"))
                data = win32file.ReadFile(handle, 65536)[1]
                response: dict[str, Any] = json.loads(data.decode("utf-8"))
                return response
            finally:
                win32file.CloseHandle(handle)
        except Exception as e:
            if pywintypes and isinstance(e, pywintypes.error):
                raise ConnectionError(f"Daemon not running (pipe not found: {pipe_name})")
            raise
